[
  {
    "objectID": "ST558-HW4.html",
    "href": "ST558-HW4.html",
    "title": "ST558-HW4",
    "section": "",
    "text": "---\ntitle: \"ST558-HW4\"\nformat: html\nauthor: \"Alex Devoid\" \ndate: \"June 18, 2024\"\npurpose: \"ST558-HW4\"\n---\n\n# Task 1: Conceptual Questions\n\n1. **What is the purpose of the `lapply()` function? What is the equivalent `purrr` function?**\n\n   The `lapply()` function in R is used to apply a function over a list or vector and return a list of the same length as the input. The equivalent function in the `purrr` package is `map()`, which also returns a list.\n\n2. **Suppose we have a list called `my_list`. Each element of the list is a numeric data frame (all columns are numeric). We want to use `lapply()` to run the code `cor(numeric_matrix, method = \"kendall\")` on each element of the list. Write code to do this below! (Iâ€™m really trying to ask you how you specify `method = \"kendall\"` when calling `lapply()`)**\n\n   ```r\n   my_list &lt;- list(\n     data.frame(a = rnorm(10), b = rnorm(10)),\n     data.frame(a = rnorm(10), b = rnorm(10))\n   )\n\n   result &lt;- lapply(my_list, function(x) cor(x, method = \"kendall\"))\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\npurrr functions have a consistent syntax and naming convention, making the code easier to read and write.\npurrr functions provide better error handling and more options for managing complex data structures, such as lists and nested lists.\n\nWhat is a side-effect function?\nA side-effect function is a function that performs an action or produces an effect beyond returning a value. Examples of side effects include modifying a global variable, printing output to the console, writing to a file, or modifying the state of an object.\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\nIn R, the scope of a variable inside a function is limited to that function. This means that naming a variable sd within a function does not interfere with the global sd function because R can differentiate between the local variable and the global function based on the context in which they are used.\n\n\nTask 2\n# Task 2 - Writing R Functions\n\n1. **Write a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE.**\n\n   ```r\n   getRMSE &lt;- function(actual, predicted, ...) {\n     sqrt(mean((actual - predicted)^2, ...))\n   }\n\nRun the following code to create some response values and predictions. Test your RMSE function using this data.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10*x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Test RMSE function\ngetRMSE(resp, pred)\n\n# Introduce NA values\nresp[c(1, 2)] &lt;- NA\n\n# Test RMSE function with NA values\ngetRMSE(resp, pred, na.rm = TRUE)\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\ngetMAE &lt;- function(actual, predicted, ...) {\n  mean(abs(actual - predicted), ...)\n}\nRun the following code to create some response values and predictions. Test your MAE function using this data.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10*x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Test MAE function\ngetMAE(resp, pred)\n\n# Introduce NA values\nresp[c(1, 2)] &lt;- NA\n\n# Test MAE function with NA values\ngetMAE(resp, pred, na.rm = TRUE)\nCreate a wrapper function that can be used to get either or both metrics returned with a single function call.\ngetMetrics &lt;- function(actual, predicted, metrics = c(\"RMSE\", \"MAE\"), ...) {\n  if (!(is.vector(actual) && is.atomic(actual) && is.numeric(actual) &&\n        is.vector(predicted) && is.atomic(predicted) && is.numeric(predicted))) {\n    message(\"Both inputs must be numeric vectors.\")\n    return(NULL)\n  }\n\n  results &lt;- list()\n  if (\"RMSE\" %in% metrics) results$RMSE &lt;- getRMSE(actual, predicted, ...)\n  if (\"MAE\" %in% metrics) results$MAE &lt;- getMAE(actual, predicted, ...)\n\n  return(results)\n}\nRun the following code to create some response values and predictions. Test your new function using this data.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10*x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Test getMetrics function\ngetMetrics(resp, pred)\ngetMetrics(resp, pred, metrics = \"RMSE\")\ngetMetrics(resp, pred, metrics = \"MAE\")\n\n# Introduce NA values\nresp[c(1, 2)] &lt;- NA\n\n# Test getMetrics function with NA values\ngetMetrics(resp, pred, na.rm = TRUE)\n\n# Test with incorrect data\ngetMetrics(data.frame(resp), pred)\ngetMetrics(resp, data.frame(pred))"
  },
  {
    "objectID": "Statistical_Functions_Assignment.html",
    "href": "Statistical_Functions_Assignment.html",
    "title": "Statistical_Functions_Assignment",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "Statistical_Functions_Assignment.html#quarto",
    "href": "Statistical_Functions_Assignment.html#quarto",
    "title": "Statistical_Functions_Assignment",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  }
]