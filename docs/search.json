[
  {
    "objectID": "Statistical_Functions_Assignment.html",
    "href": "Statistical_Functions_Assignment.html",
    "title": "ST558-HW4",
    "section": "",
    "text": "Task 1: Conceptual Questions\n\nWhat is the purpose of the lapply() function? What is the equivalent purrr function?\nThe lapply() function in R is used to apply a function over a list or vector and return a list of the same length as the input. The equivalent function in the purrr package is map(), which also returns a list.\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below! (Iâ€™m really trying to ask you how you specify method = \"kendall\" when calling lapply())\n\nmy_list &lt;- list(\n  data.frame(a = rnorm(10), b = rnorm(10)),\n  data.frame(a = rnorm(10), b = rnorm(10))\n)\n\nresult &lt;- lapply(my_list, function(x) cor(x, method = \"kendall\"))\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\npurrr functions have a consistent syntax and naming convention, making the code easier to read and write.\npurrr functions provide better error handling and more options for managing complex data structures, such as lists and nested lists.\n\nWhat is a side-effect function?\nA side-effect function is a function that performs an action or produces an effect beyond returning a value. Examples of side effects include modifying a global variable, printing output to the console, writing to a file, or modifying the state of an object.\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\nIn R, the scope of a variable inside a function is limited to that function. This means that naming a variable sd within a function does not interfere with the global sd function because R can differentiate between the local variable and the global function based on the context in which they are used.\n\n\n\nTask 2 - Writing R Functions\n\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE.\n\nlibrary(tidyverse)\ngetRMSE &lt;- function(actual, predicted, ...) {\nsqrt(mean((actual - predicted)^2, ...))\n}\n\nRun the following code to create some response values and predictions. Test your RMSE function using this data.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10*x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Test RMSE function\ngetRMSE(resp, pred)\n\n# Introduce NA values\nresp[c(1, 2)] &lt;- NA\n\n# Test RMSE function with NA values\ngetRMSE(resp, pred, na.rm = TRUE)\n\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\ngetMAE &lt;- function(actual, predicted, ...) {\n  mean(abs(actual - predicted), ...)\n}\nRun the following code to create some response values and predictions. Test your MAE function using this data.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10*x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Test MAE function\ngetMAE(resp, pred)\n\n# Introduce NA values\nresp[c(1, 2)] &lt;- NA\n\n# Test MAE function with NA values\ngetMAE(resp, pred, na.rm = TRUE)\nCreate a wrapper function that can be used to get either or both metrics returned with a single function call.\ngetMetrics &lt;- function(actual, predicted, metrics = c(\"RMSE\", \"MAE\"), ...) {\n  if (!(is.vector(actual) && is.atomic(actual) && is.numeric(actual) &&\n        is.vector(predicted) && is.atomic(predicted) && is.numeric(predicted))) {\n    message(\"Both inputs must be numeric vectors.\")\n    return(NULL)\n  }\n\n  results &lt;- list()\n  if (\"RMSE\" %in% metrics) results$RMSE &lt;- getRMSE(actual, predicted, ...)\n  if (\"MAE\" %in% metrics) results$MAE &lt;- getMAE(actual, predicted, ...)\n\n  return(results)\n}\nRun the following code to create some response values and predictions. Test your new function using this data.\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10*x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# Test getMetrics function\ngetMetrics(resp, pred)\ngetMetrics(resp, pred, metrics = \"RMSE\")\ngetMetrics(resp, pred, metrics = \"MAE\")\n\n# Introduce NA values\nresp[c(1, 2)] &lt;- NA\n\n# Test getMetrics function with NA values\ngetMetrics(resp, pred, na.rm = TRUE)\n\n# Test with incorrect data\ngetMetrics(data.frame(resp), pred)\ngetMetrics(resp, data.frame(pred))\n\n\n\nTask 3 - Querying an API and a Tidy-Style Function\n\nUse GET() from the httr package to return information about a topic that you are interested in that has been in the news lately.\nlibrary(httr)\nlibrary(dplyr)\n\napi_key &lt;- \"98bec7bb7a124469b04c6e019b33abee\"\nurl &lt;- \"https://newsapi.org/v2/everything\"\nparams &lt;- list(\n  q = \"technology\",\n  from = Sys.Date() - 30,\n  sortBy = \"publishedAt\",\n  apiKey = api_key\n)\n\nresponse &lt;- GET(url, query = params)\narticles &lt;- content(response)$articles\narticles_df &lt;- bind_rows(lapply(articles, as.data.frame))\nParse what is returned and find your way to the data frame that has the actual article information in it.\narticles_df &lt;- bind_rows(lapply(articles, as.data.frame))\nWrite a quick function that allows the user to easily query this API.\nget_news &lt;- function(query, from_date, api_key) {\n  url &lt;- \"https://newsapi.org/v2/everything\"\n  params &lt;- list(\n    q = query,\n    from = from_date,\n    sortBy = \"publishedAt\",\n    apiKey = api_key\n  )\n  response &lt;- GET(url, query = params)\n  articles &lt;- content(response)$articles\n  articles_df &lt;- bind_rows(lapply(articles, as.data.frame))\n  return(articles_df)\n}\n\n# Test the function\nnews1 &lt;- get_news(\"technology\", Sys.Date() - 30, api_key)\nnews2 &lt;- get_news(\"science\", Sys.Date() - 30, api_key)"
  }
]